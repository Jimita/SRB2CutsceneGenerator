/**
 * This class lets you encode animated GIF files
 * Base class :  http://www.java2s.com/Code/Java/2D-Graphics-GUI/AnimatedGifEncoder.htm
 * @author Kevin Weiner (original Java version - kweiner@fmsware.com)
 * @author Thibault Imbert (AS3 version - bytearray.org)
 * @author Kevin Kwok (JavaScript version - https://github.com/antimatter15/jsgif)
 * @author Jaime Passos (modified to closely match Sonic Robo Blast 2's movie mode)
 * @version 0.1 AS3 implementation
 */

GIFEncoder = function() {

	for (var i = 0, chr = {}; i < 256; i++)
		chr[i] = String.fromCharCode(i);

	function ByteArray() {
		this.bin = [];
	}

	ByteArray.prototype.getData = function() {
		for (var v = '', l = this.bin.length, i = 0; i < l; i++)
			v += chr[this.bin[i]];
		return v;
	};

	ByteArray.prototype.writeByte = function(val) {
		this.bin.push(val);
	};

	ByteArray.prototype.writeUTFBytes = function(string) {
		for (var l = string.length, i = 0; i < l; i++)
			this.writeByte(string.charCodeAt(i));
	};

	ByteArray.prototype.writeBytes = function(array, offset, length) {
		for (var l = length || array.length, i = offset || 0; i < l; i++)
			this.writeByte(array[i]);
	};

	var exports = {};
	var width; // image size
	var height;
	var framex, framey, framewidth, frameheight, framechanged;
	var downscale = 1; // downscale amount
	var transparent = null; // transparent color if given
	var transIndex; // transparent index in color table
	var repeat = -1; // no repeat
	var delay = 0; // frame delay (hundredths)
	var started = false; // ready to output frames
	var out;
	var image; // current frame
	var pixels; // BGR byte array from frame
	var lastPixels; // BGR byte array from last frame
	var optimize = false; // frame optimization
	var indexedPixels; // converted frame indexed to palette
	var colorDepth = 8; // number of bit planes
	var colorTab; // RGB palette
	var palSize = 7; // color table size (bits-1)
	var dispose = -1; // disposal code (-1 = use default)
	var closeStream = false; // close stream when finished
	var firstFrame = true;
	var sizeSet = false; // if false, get size from first frame
	var comment = "Generated by jsgif (https://github.com/antimatter15/jsgif/)"; // default comment for generated gif
	var cachedPaletteLookup = null;

	/**
	 * Sets the delay time between each frame, or changes it for subsequent frames
	 * (applies to last frame added)
	 * int delay time in milliseconds
	 * @param ms
	 */

	var setDelay = exports.setDelay = function setDelay(ms) {
		delay = Math.round(ms / 10);
	};

	/**
	 * Sets the GIF frame disposal code for the last added frame and any
	 *
	 * subsequent frames. Default is 0 if no transparent color has been set,
	 * otherwise 2.
	 * @param code
	 * int disposal code.
	 */

	var setDispose = exports.setDispose = function setDispose(code) {
		if (code >= 0) dispose = code;
	};

	/**
	 * Sets the number of times the set of GIF frames should be played. Default is
	 * 1; 0 means play indefinitely. Must be invoked before the first image is
	 * added.
	 *
	 * @param iter
	 * int number of iterations.
	 * @return
	 */

	var setRepeat = exports.setRepeat = function setRepeat(iter) {
		if (iter >= 0) repeat = iter;
	};

	/**
	 * Sets the transparent color for the last added frame and any subsequent
	 * frames. Since all colors are subject to modification in the quantization
	 * process, the color in the final palette for each frame closest to the given
	 * color becomes the transparent color for that frame. May be set to null to
	 * indicate no transparent color.
	 * @param
	 * Color to be treated as transparent on display.
	 */

	var setTransparent = exports.setTransparent = function setTransparent(c) {
		transparent = c;
	};


	/**
	 * Sets the comment for the block comment
	 * @param
	 * string to be insterted as comment
	 */

	var setComment = exports.setComment = function setComment(c) {
		comment = c;
	};

	/**
	 * Enables or disable optimization
	 * @param
	 * optimization flag
	 */

	var setOptimization = exports.setOptimization = function setOptimization(c) {
		optimize = c;
	};



	/**
	 * The addFrame method takes an incoming BitmapData object to create each frames
	 * @param
	 * BitmapData object to be treated as a GIF's frame
	 */

	var addFrame = exports.addFrame = function addFrame(im, is_imageData) {

		if ((im === null) || !started || out === null) {
			throw new Error("Please call start method before calling addFrame");
		}

		var ok = true;

		try {
			if (!is_imageData) {
				image = im.getImageData(0, 0, im.canvas.width, im.canvas.height).data;
				if (!sizeSet) setSize(im.canvas.width, im.canvas.height);
			} else {
				if(im instanceof ImageData) {
					image = im.data;
					if(!sizeset || width!=im.width || height!=im.height) {
						setSize(im.width,im.height);
					}
				} else if(im instanceof Uint8ClampedArray) {
					if(im.length==(width*height*4)) {
						image=im;
					} else {
						console.log("Please set the correct size: ImageData length mismatch");
						ok=false;
					}
				} else {
					console.log("Please provide correct input");
					ok=false;
				}
			}

			framewidth = width;
			frameheight = height;
			framex = 0;
			framey = 0;
			framechanged = true;

			getImagePixels(); // convert to correct format if necessary

			// Lactozilla: optimize frame
			if (optimize)
			{
				if (!firstFrame)
					optimizeRegion(pixels, lastPixels);

				if (framechanged)
					lastPixels = pixels.slice(0); // Lactozilla: slice is faster than the spread operator
			}

			if (framechanged && downscale > 1)
			{
				// Ensure our downscaled framex/y starts and ends on a pixel.
				framex /= downscale;
				framey /= downscale;
				framewidth = ((framewidth + (downscale - 1)) / downscale);
				frameheight = ((frameheight + (downscale - 1)) / downscale);

				framex = Math.floor(framex);
				framey = Math.floor(framey);
				framewidth = Math.floor(framewidth);
				frameheight = Math.floor(frameheight);
			}

			analyzePixels(); // build color table & map pixels

			if (firstFrame) {
				writeLSD(); // logical screen descriptior
				writePalette(); // global color table
				if (repeat >= 0) {
					// use NS app extension to indicate reps
					writeNetscapeExt();
				}
			}

			writeGraphicCtrlExt(); // write graphic control extension
			if (comment !== '') {
				writeCommentExt(); // write comment extension
			}
			writeImageDesc(); // image descriptor
			writePixels(); // encode and write pixel data
			firstFrame = false;
		} catch (e) {
			ok = false;
		}

		return ok;
	};

	/**
	* @description: Downloads the encoded gif with the given name
	* No need of any conversion from the stream data (out) to base64
	* Solves the issue of large file sizes when there are more frames
	* and does not involve in creation of any temporary data in the process
	* so no wastage of memory, and speeds up the process of downloading
	* to just calling this function.
	* @parameter {String} filename filename used for downloading the gif
	*/

	var download = exports.download = function download(filename) {
		if(out===null || closeStream==false) {
			console.log("Please call start method and add frames and call finish method before calling download");
		} else {
			filename= filename !== undefined ? ( filename.endsWith(".gif")? filename: filename+".gif" ): "download.gif";
			var templink = document.createElement("a");
			templink.download=filename;
			templink.href= URL.createObjectURL(new Blob([new Uint8Array(out.bin)], {type : "image/gif" } ));
			templink.click();
		}
	}

	/**
	 * Adds final trailer to the GIF stream, if you don't call the finish method
	 * the GIF stream will not be valid.
	 */

	var finish = exports.finish = function finish() {

		if (!started) return false;

		var ok = true;
		started = false;

		try {
			out.writeByte(0x3b); // gif trailer
			closeStream=true;
		} catch (e) {
			ok = false;
		}

		colorTab = null;
		cachedPaletteLookup = null;

		return ok;
	};

	/**
	 * Resets some members so that a new stream can be started.
	 * This method is actually called by the start method
	 */

	var reset = function reset() {

		// reset for subsequent use
		transIndex = 0;
		image = null;
		pixels = null;
		indexedPixels = null;
		closeStream = false;
		firstFrame = true;
	};

	/**
	 * * Sets frame rate in frames per second. Equivalent to
	 * <code>setDelay(1000/fps)</code>.
	 * @param fps
	 * float frame rate (frames per second)
	 */

	var setFrameRate = exports.setFrameRate = function setFrameRate(fps) {
		if (fps != 0xf) delay = Math.round(100 / fps);
	};

	/**
	 * Sets the global palette.
	 * @param globalPalette
	 * The palette.
	 */
	var setPalette = exports.setPalette = function setPalette(globalPalette) {
		colorTab = globalPalette;
	};

	/**
	 * Sets the downscaling amount.
	 * @param downscalingAmount
	 * The downscaling amount.
	 */
	var setDownscaling = exports.setDownscaling = function setPalette(downscalingAmount) {
		downscale = downscalingAmount;
	};

	/**
	 * Sets the GIF frame size. The default size is the size of the first frame
	 * added if this method is not invoked.
	 * @param w
	 * int frame width.
	 * @param h
	 * int frame width.
	 */

	var setSize = exports.setSize = function setSize(w, h) {

		if (started && !firstFrame) return;
		width = w;
		height = h;
		if (width < 1) width = 320;
		if (height < 1) height = 200;
		sizeSet = true;
	};

	/**
	 * Initiates GIF file creation on the given stream.
	 * @param os
	 * OutputStream on which GIF images are written.
	 * @return false if initial write failed.
	 */

	var start = exports.start = function start() {

		reset();
		var ok = true;
		closeStream = false;
		out = new ByteArray();
		try {
			out.writeUTFBytes("GIF89a"); // header
		} catch (e) {
			ok = false;
		}

		return started = ok;
	};

	var cont = exports.cont = function cont() {

		reset();
		var ok = true;
		closeStream = false;
		out = new ByteArray();

		return started = ok;
	};

	/**
	 * Analyzes image colors and creates color map.
	 */

	var analyzePixels = function analyzePixels() {

		var len = pixels.length;
		var x, y;

		// map image pixels to new palette
		if (framechanged)
		{
			indexedPixels = new Uint8Array(framewidth * frameheight);
			var srcx;
			var srcy = 0;

			for (y = 0; y < frameheight; y++) {
				srcx = 0;
				for (x = 0; x < framewidth; x++) {
					// Lactozilla
					var top = (srcy + (framey * downscale)) * (width);
					var left = (srcx + (framex * downscale));
					var idx = (top * 3) + (left * 3);
					var index = findClosest(pixels[idx], pixels[idx + 1], pixels[idx + 2]);
					indexedPixels[(y * framewidth) + x] = index;
					srcx += downscale;
				}
				srcy += downscale;
			}
		}
		else
			indexedPixels[0] = findClosest(pixels[0], pixels[1], pixels[2]);
	};

	/**
	 * Returns index of palette color closest to c
	 */

	var findClosest = function findClosest(r, g, b) {
		if (colorTab === null) return -1;

		var minpos = 0;
		var dmin = 256 * 256 * 4;

		// Lactozilla
		if (cachedPaletteLookup == null)
		{
			cachedPaletteLookup = new Uint16Array(0xFFFF);
			cachedPaletteLookup.fill(65535);
		}

		var rgb = ((r >> 3) << 11) | ((g >> 2) << 5) | ((b >> 3) << 0);
		if (cachedPaletteLookup[rgb] != 65535)
			return cachedPaletteLookup[rgb];

		for (var i = 0; i < 256; i++) {
			var dr = r - colorTab[i][0];
			var dg = g - colorTab[i][1];
			var db = b - colorTab[i][2];
			var d = dr * dr + dg * dg + db * db;
			if (d < dmin) {
				if (!d)
				{
					cachedPaletteLookup[rgb] = i;
					return i;
				}
				dmin = d;
				minpos = i;
			}
		}

		cachedPaletteLookup[rgb] = minpos;
		return minpos;
	};

	/**
	 * Extracts image pixels into byte array "pixels
	 */

	var getImagePixels = function getImagePixels() {
		var w = width;
		var h = height;

		var data = image;
		var src = 0;
		var count = 0;
		var i, j;

		if (pixels == null)
			pixels = new Uint8Array(w * h * 3);

		for (i = 0; i < h; i++)
		{
			for (j = 0; j < w; j++)
			{
				pixels[count++] = data[src++];
				pixels[count++] = data[src++];
				pixels[count++] = data[src++];
				src++;
			}
		}
	};

	/**
	 * Compares two arrays of colors.
	 */

	function compareRowArrays(a, b, pos, len) {
		for (var i = 0; i < (len * 3); i++)
		{
			if (a[i + pos] != b[i + pos])
				return false;
		}
		return true;
	}

	/**
	 * Compares two colors.
	 */

	function compareRowColors(a, b, pos) {
		return (a[pos] == b[pos]
			&& a[pos+1] == b[pos+1]
			&& a[pos+2] == b[pos+2]);
	}

	/**
	 * Checks a row for modification, and if any is detected, what parts.
	 * Ported from Sonic Robo Blast 2 - see m_anigif.c
	 */
	var optimizeCompareRow = function optimizeCompareRow(dst, src, row, last, left, right)
	{
		var sp = src;
		var dp = dst;
		var pos = (width * row * 3);
		var tmp;
		var doleft = true;
		var doright = true;
		var i;

		if (compareRowArrays(sp, dp, pos, width))
			return [false, last, left, right]; // unchanged.

		last = row;

		// left side
		i = 0;
		if (left == 0) // edge reached
			doleft = 0;
		else if (left > 0) // left set, nonzero
		{
			if (compareRowArrays(sp, dp, pos, left))
				doleft = false; // left side not changed
		}
		while (doleft)
		{
			tmp = pos + (i * 3);
			if (i > width)
			{
				left = 0;
				break;
			}
			if (compareRowColors(dp, sp, tmp))
			{
				doleft = false;
				left = i;
			}
			++i;
		}

		// right side
		i = width - 1;
		if (right == width - 1) // edge reached
			doright = 0;
		else if (right >= 0) // right set, non-end-of-width
		{
			tmp = pos + ((right + 1) * 3);
			if (compareRowArrays(sp, dp, tmp, width - (right + 1)))
				doright = false; // right side not changed
		}
		while (doright)
		{
			tmp = pos + (i * 3);
			if (i < 0)
			{
				right = width - 1;
				break;
			}
			if (compareRowColors(dp, sp, tmp))
			{
				doright = false;
				right = i;
			}
			--i;
		}
		return [true, last, left, right];
	}

	/**
	 * Attempts to optimize a GIF as it's being written, by giving a region
	 * containing all of the changed pixels, instead of rewriting
	 * the entire screen buffer to the GIF file every frame.
	 * Ported from Sonic Robo Blast 2 - see m_anigif.c
	 */
	var optimizeRegion = function optimizeRegion(dst, src)
	{
		var st = 0;
		var sb = height - 1; // work from both directions

		// store first changed row.
		var firstchg_t = -1;
		var firstchg_b = -1;

		// Store last row... just in case
		var lastchg_t = -1;
		var lastchg_b = -1;

		// store left and rightmost change
		var lmpix = -1;
		var rmpix = -1;

		var stopt = false;
		var stopb = false;

		while ((!stopt || !stopb) && st < sb)
		{
			if (!stopt)
			{
				var optimized = optimizeCompareRow(dst, src, st++, lastchg_t, lmpix, rmpix);
				lastchg_t     = optimized[1];
				lmpix         = optimized[2];
				rmpix         = optimized[3];

				if ((optimized[0] == true) && lmpix == 0 && rmpix == width - 1)
					stopt = true;
				if (firstchg_t < 0 && lastchg_t >= 0)
					firstchg_t = lastchg_t;
			}
			if (!stopb)
			{
				var optimized = optimizeCompareRow(dst, src, sb--, lastchg_t, lmpix, rmpix);
				lastchg_t     = optimized[1];
				lmpix         = optimized[2];
				rmpix         = optimized[3];

				if ((optimized[0] == true) && lmpix == 0 && rmpix == width - 1)
					stopb = true;
				if (firstchg_b < 0 && lastchg_b >= 0)
					firstchg_b = lastchg_b;
			}
		}

		if (lmpix < 0) // NO CHANGE.
		{
			// hack: we don't attempt to go back and rewrite the previous
			// frame's delay, we just make this frame have only a single
			// pixel so it contains minimal data
			framex = framey = 0;
			framewidth = frameheight = 1;
			framechanged = false;
			return;
		}

		var top    = ((firstchg_b < 0 && lastchg_t >= 0) ? lastchg_t : firstchg_b);
		var bottom = ((firstchg_t < 0 && lastchg_b >= 0) ? lastchg_b : firstchg_t) + 1;

		// Lactozilla: Swap the bottom with the top if it is the top
		if (top > bottom)
		{
			var swap = top;
			top = bottom;
			bottom = swap;

			// Also adjust the rows
			top--;
			bottom++;
		}

		framex = lmpix;
		framey = top;
		framewidth = rmpix + 1;
		frameheight = bottom;

		framewidth = (framewidth - framex);
		frameheight = (frameheight - framey);
	}

	/**
	 * Writes Graphic Control Extension
	 */

	var writeGraphicCtrlExt = function writeGraphicCtrlExt() {
		out.writeByte(0x21); // extension introducer
		out.writeByte(0xf9); // GCE label
		out.writeByte(4); // data block size
		var transp;
		var disp;
		if (transparent === null) {
			transp = 0;
			disp = 0; // dispose = no action
		} else {
			transp = 1;
			disp = 2; // force clear if using transparent color
		}
		if (dispose >= 0) {
			disp = dispose & 7; // user override
		}
		disp <<= 2;
		// packed fields
		out.writeByte(0 | // 1:3 reserved
			disp | // 4:6 disposal
			0 | // 7 user input - 0 = none
			transp); // 8 transparency flag

		WriteShort(delay); // delay x 1/100 sec
		out.writeByte(transIndex); // transparent color index
		out.writeByte(0); // block terminator
	};

	/**
	 * Writes Comment Extention
	 */

	var writeCommentExt = function writeCommentExt() {
		out.writeByte(0x21); // extension introducer
		out.writeByte(0xfe); // comment label
		out.writeByte(comment.length); // Block Size (s)
		out.writeUTFBytes(comment);
		out.writeByte(0); // block terminator
	};


	/**
	 * Writes Image Descriptor
	 */

	var writeImageDesc = function writeImageDesc() {

		out.writeByte(0x2c); // image separator
		WriteShort(framex); // image position x,y = 0,0
		WriteShort(framey);
		WriteShort(framewidth); // image size
		WriteShort(frameheight);

		// Lactozilla: no LCT at all
		out.writeByte(0);
	};

	/**
	 * Writes Logical Screen Descriptor
	 */

	var writeLSD = function writeLSD() {

		// logical screen size
		WriteShort(width / downscale);
		WriteShort(height / downscale);
		// packed fields
		out.writeByte((0x80 | // 1 : global color table flag = 1 (gct used)
			0x70 | // 2-4 : color resolution = 7
			0x00 | // 5 : gct sort flag = 0
			palSize)); // 6-8 : gct size

		out.writeByte(0); // background color index
		out.writeByte(0); // pixel aspect ratio - assume 1:1
	};

	/**
	 * Writes Netscape application extension to define repeat count.
	 */

	var writeNetscapeExt = function writeNetscapeExt() {
		out.writeByte(0x21); // extension introducer
		out.writeByte(0xff); // app extension label
		out.writeByte(11); // block size
		out.writeUTFBytes("NETSCAPE" + "2.0"); // app id + auth code
		out.writeByte(3); // sub-block size
		out.writeByte(1); // loop sub-block id
		WriteShort(repeat); // loop count (extra iterations, 0=repeat forever)
		out.writeByte(0); // block terminator
	};

	/**
	 * Writes color table
	 */

	var writePalette = function writePalette() {
		for (var i = 0; i < 256; i++)
			out.writeBytes(colorTab[i]);
	};

	var WriteShort = function WriteShort(pValue) {
		out.writeByte(pValue & 0xFF);
		out.writeByte((pValue >> 8) & 0xFF);
	};

	/**
	 * Encodes and writes pixel data
	 */

	var writePixels = function writePixels() {
		var myencoder = new LZWEncoder(framewidth, frameheight, indexedPixels, colorDepth);
		myencoder.encode(out);
	};

	/**
	 * Retrieves the GIF stream
	 */

	var stream = exports.stream = function stream() {
		return out;
	};

	var setProperties = exports.setProperties = function setProperties(has_start, is_first) {
		started = has_start;
		firstFrame = is_first;
	};

	return exports;

};
